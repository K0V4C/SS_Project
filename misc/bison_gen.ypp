%{
#include <iostream>
#include <string>
#include <vector>
#include <stdint.h>

#include "../inc/parser.hpp"
#include "../inc/collector.hpp"

extern int yylex();
extern int yyparse();
extern FILE* yyin;

void yyerror(const char *s);
%}


%union {
    int32_t num;
    char* sym;
}

%token COMMENT

%token SEMYCOLON COLON COMMA NEW_LINE

%token GLOBAL EXTERN SECTION WORD SKIP ASCII EQU END

%token HALT INT IRET CALL RET JMP BEQ BNE BGT PUSH POP XCHG
%token ADD SUB MUL DIV NOT AND OR XOR SHL SHR LD ST CSRRD CSRWR

%token PLUS MINUS MULTIPLY DIVISION LEFT_BRACKET RIGHT_BRACKET

%token DOLLAR_SIGN

%token<sym> IDENTIFIER
%token REGISTER
%token STATUS_REG HANDLER_REG CAUSE_REG SP_REG
%token DECIMAL_NUM HEX_NUM

%token STRING
%token END_OF_FILE

%%

program:
| program label
| program END_OF_FILE {return 1;}
| program directive
| program NEW_LINE
| program instruction
;

label:
    IDENTIFIER COLON {}
;

symbols:
    IDENTIFIER {
        auto& c = Collector::get_instance();
        std::string new_symbol($1);
        c.append_symbol(new_symbol);
    }
|   symbols COMMA IDENTIFIER {
    auto& c = Collector::get_instance();
    std::string new_symbol($3);
    c.append_symbol(new_symbol);
}
;

literal:
    DECIMAL_NUM {;}
|   HEX_NUM {;}
;

literal_list:
    literal {;}
|   literal_list COMMA literal 
;

operand:
    DOLLAR_SIGN literal {;}
|   DOLLAR_SIGN IDENTIFIER {;}
|   literal {;}
|   IDENTIFIER {;}
|   REGISTER {;}
|   LEFT_BRACKET REGISTER RIGHT_BRACKET {;}
|   LEFT_BRACKET REGISTER PLUS literal RIGHT_BRACKET {;}
|   LEFT_BRACKET REGISTER PLUS IDENTIFIER RIGHT_BRACKET {;}
;

gpr:
    REGISTER
|   SP_REG
;

csr:
    STATUS_REG
|   HANDLER_REG
|   CAUSE_REG
;

instruction:
    halt_instruction
|   int_instruction
|   call_instruction
|   push_instruction
|   pop_instruction
|   ld_instrucion
|   st_instruction
|   csrwr_instruction
;

halt_instruction:
    HALT
;

int_instruction:
    INT 
;

call_instruction:
    CALL operand
;

push_instruction:
    PUSH gpr
;

pop_instruction:
    POP gpr
;

ld_instrucion:
    LD operand COMMA gpr
;

st_instruction:
    ST gpr COMMA operand
;

csrwr_instruction:
    CSRWR gpr COMMA csr 
;

directive:
    global_directive
|   extern_directive
|   section_directive
|   word_directive
|   skip_directive
|   ascii_directive
|   equ_directive
|   end_directive
;

global_directive:
    GLOBAL symbols {;}
;
extern_directive:
    EXTERN symbols {
        auto& c = Collector::get_instance();
            auto arr = c.get_symbol_list();

            for(auto g : arr) {
                std::cout << g << std::endl;
            }
    }
;
section_directive:
    SECTION IDENTIFIER
;
word_directive:
    WORD symbols {/* OVA mora da se doraid*/}
|   WORD literal_list
;
skip_directive:
    SKIP DECIMAL_NUM {/*mora da se doradi*/}
;
ascii_directive:
    ASCII STRING {;}
;
equ_directive:
    EQU IDENTIFIER {/*Mora da se doradi*/}
;
end_directive:
    END {;}
;



%%

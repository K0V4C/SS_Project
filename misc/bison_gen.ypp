%{
#include <iostream>
#include <string>
#include <vector>
#include <stdint.h>
#include <memory>

#include "../inc/parser.hpp"
#include "../inc/collector.hpp"

#include "../inc/asembler.hpp"
#include "../inc/asm_actions/actions.hpp"
#include "../inc/asm_actions/directive_actions.hpp"
#include "../inc/asm_actions/instruction_actions.hpp"
#include "../inc/asm_actions/label_actions.hpp"

extern int yylex();
extern int yyparse();
extern FILE* yyin;

void yyerror(const char *s);
%}


%union {
    int32_t num;
    char* sym;
}

%token COMMENT

%token SEMYCOLON COLON COMMA NEW_LINE

%token GLOBAL EXTERN SECTION WORD SKIP ASCII EQU END

%token HALT INT IRET CALL RET JMP BEQ BNE BGT PUSH POP XCHG
%token ADD SUB MUL DIV NOT AND OR XOR SHL SHR LD ST CSRRD CSRWR

%token PLUS MINUS MULTIPLY DIVISION LEFT_BRACKET RIGHT_BRACKET

%token DOLLAR_SIGN

%token<sym> IDENTIFIER
%token REGISTER
%token STATUS_REG HANDLER_REG CAUSE_REG SP_REG PC_REG
%token DECIMAL_NUM HEX_NUM

%token STRING
%token END_OF_FILE

%%

program:
| program label
| program END_OF_FILE {return 1;}
| program directive
| program NEW_LINE
| program instruction
;

label:
    IDENTIFIER COLON {}
;

symbols:
    IDENTIFIER {
        auto& c = Collector::get_instance();
        std::string new_symbol($1);
        c.append_symbol(new_symbol);
    }
|   symbols COMMA IDENTIFIER {
    auto& c = Collector::get_instance();
    std::string new_symbol($3);
    c.append_symbol(new_symbol);
}
;

literal:
    DECIMAL_NUM {;}
|   HEX_NUM {;}
;

literal_list:
    literal {;}
|   literal_list COMMA literal 
;

operand:
    DOLLAR_SIGN literal {;}
|   DOLLAR_SIGN IDENTIFIER {;}
|   literal {;}
|   IDENTIFIER {;}
|   gpr {;}
|   LEFT_BRACKET gpr RIGHT_BRACKET {;}
|   LEFT_BRACKET gpr PLUS literal RIGHT_BRACKET {;}
|   LEFT_BRACKET gpr PLUS IDENTIFIER RIGHT_BRACKET {;}
;

branch_operand:
    IDENTIFIER
|   literal
;

gpr:
    REGISTER
|   SP_REG
|   PC_REG
;

csr:
    STATUS_REG
|   HANDLER_REG
|   CAUSE_REG
;

instruction:
    halt_instruction
|   int_instruction
|   iret_instruction
|   call_instruction
|   ret_instruction
|   jmp_instruction
|   beq_instruction
|   bne_instruction
|   bgt_instruction
|   push_instruction
|   pop_instruction
|   xchg_instrucion
|   add_instruction
|   sub_instrucion
|   mul_instruction
|   div_instruction
|   not_instruction
|   and_instruction
|   or_instruction
|   xor_instruction
|   shl_instruction
|   shr_instruction
|   ld_instrucion
|   st_instruction
|   csrrd_instruction
|   csrwr_instruction
;

halt_instruction:
    HALT
;

int_instruction:
    INT 
;

iret_instruction:
    IRET
;

call_instruction:
    CALL branch_operand
;

ret_instruction:
    RET
;

jmp_instruction:
    JMP branch_operand
;

beq_instruction:
    BEQ gpr COMMA gpr COMMA branch_operand
;

bne_instruction:
    BNE gpr COMMA gpr COMMA branch_operand
;

bgt_instruction:
    BGT gpr COMMA gpr branch_operand
;

push_instruction:
    PUSH gpr
;

pop_instruction:
    POP gpr
;

xchg_instrucion:
    XCHG gpr COMMA gpr
;

add_instruction:
    ADD gpr COMMA gpr
;

sub_instrucion:
    SUB gpr COMMA gpr
;

mul_instruction:
    MUL gpr COMMA gpr
;

div_instruction:
    DIV gpr COMMA gpr
;

not_instruction:
    NOT gpr
;

and_instruction:
    AND gpr COMMA gpr
;

or_instruction:
    OR gpr COMMA gpr
;

xor_instruction:
    XOR gpr COMMA gpr
;

shl_instruction:
    SHL gpr COMMA gpr
;

shr_instruction:
   SHR gpr COMMA gpr
;

ld_instrucion:
    LD operand COMMA gpr
;

st_instruction:
    ST gpr COMMA operand
;

csrrd_instruction:
    CSRRD csr COMMA gpr
;

csrwr_instruction:
    CSRWR gpr COMMA csr 
;

directive:
    global_directive
|   extern_directive
|   section_directive
|   word_directive
|   skip_directive
|   ascii_directive
|   equ_directive
|   end_directive
;

global_directive:
    GLOBAL symbols {;}
;
extern_directive:
    EXTERN symbols {
        auto& c = Collector::get_instance();
        auto arr = c.get_symbol_list();
        
        Asembler::file_actions.push_back(
            std::make_unique<directive_extern>(arr)
        );

        c.clear_symbol_list();

    }
;
section_directive:
    SECTION IDENTIFIER
;
word_directive:
    WORD symbols {/* OVA mora da se doraid*/}
|   WORD literal_list
;
skip_directive:
    SKIP literal {/*mora da se doradi*/}
;
ascii_directive:
    ASCII STRING {;}
;
equ_directive:
    EQU IDENTIFIER COMMA {/*Mora da se doradi*/}
;
end_directive:
    END {;}
;



%%

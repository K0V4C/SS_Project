%{
#include <iostream>
#include <string>
#include <vector>
#include <stdint.h>
#include <memory>
#include <stdint.h>
#include <variant>
#include "../inc/parser.hpp"
#include "../inc/collector.hpp"

#include "../inc/asembler.hpp"
#include "../inc/asm_actions/actions.hpp"
#include "../inc/asm_actions/directive_actions.hpp"
#include "../inc/asm_actions/instruction_actions.hpp"
#include "../inc/asm_actions/label_actions.hpp"

extern int yylex();
extern int yyparse();
extern FILE* yyin;

void yyerror(const char *s);
%}


%union {
    int32_t num;
    char* sym;
}

%token COMMENT

%token SEMYCOLON COLON COMMA NEW_LINE

%token GLOBAL EXTERN SECTION WORD SKIP ASCII EQU END

%token HALT INT IRET CALL RET JMP BEQ BNE BGT PUSH POP XCHG
%token ADD SUB MUL DIV NOT AND OR XOR SHL SHR LD ST CSRRD CSRWR

%token PLUS MINUS MULTIPLY DIVISION LEFT_BRACKET RIGHT_BRACKET

%token DOLLAR_SIGN

%token<sym> IDENTIFIER
%token<num> REGISTER
%token STATUS_REG HANDLER_REG CAUSE_REG SP_REG PC_REG
%token<num> DECIMAL_NUM
%token<num> HEX_NUM

%token STRING
%token END_OF_FILE

%type<num> literal

%%

program:
| program label
| program END_OF_FILE {return 1;}
| program directive
| program NEW_LINE
| program instruction
;

label:
    IDENTIFIER COLON {}
;

symbols:
    IDENTIFIER {
        auto& c = Collector::get_instance();
        sym_or_lit new_element = std::string($1);
        c.add_symbol_or_literal(new_element);
    }
|   symbols COMMA IDENTIFIER {
        auto& c = Collector::get_instance();
        sym_or_lit new_element = std::string($3);
        c.add_symbol_or_literal(new_element);
    }
;

literal:
    DECIMAL_NUM { $$ = $1;}
|   HEX_NUM     { $$ = $1;}
;

literal_list:
    literal {
        auto& c = Collector::get_instance();
        sym_or_lit new_element = $1;
        c.add_symbol_or_literal(new_element);
    }
|   literal_list COMMA literal {
        auto& c = Collector::get_instance();
        sym_or_lit new_element = $3;
        c.add_symbol_or_literal(new_element); 
    }
;

operand:
    DOLLAR_SIGN literal {;}
|   DOLLAR_SIGN IDENTIFIER {;}
|   literal {;}
|   IDENTIFIER {;}
|   gpr {;}
|   LEFT_BRACKET gpr RIGHT_BRACKET {;}
|   LEFT_BRACKET gpr PLUS literal RIGHT_BRACKET {;}
|   LEFT_BRACKET gpr PLUS IDENTIFIER RIGHT_BRACKET {;}
;

branch_operand:
    IDENTIFIER {
        sym_or_lit op;
        op = std::string($1);
        Collector::get_instance().set_branch_operand(op);
    }
|   literal    {
        sym_or_lit op;
        op = $1;
        Collector::get_instance().set_branch_operand(op);
    }
;

gpr:
    REGISTER {Collector::get_instance().append_gpr($1) ;}
|   SP_REG   {Collector::get_instance().append_gpr(14) ;}
|   PC_REG   {Collector::get_instance().append_gpr(15) ;}
;

csr:
    STATUS_REG  {/*TODO*/}
|   HANDLER_REG {/*TODO*/}
|   CAUSE_REG   {/*TODO*/}
;

instruction:
    halt_instruction
|   int_instruction
|   iret_instruction
|   call_instruction
|   ret_instruction
|   jmp_instruction
|   beq_instruction
|   bne_instruction
|   bgt_instruction
|   push_instruction
|   pop_instruction
|   xchg_instrucion
|   add_instruction
|   sub_instrucion
|   mul_instruction
|   div_instruction
|   not_instruction
|   and_instruction
|   or_instruction
|   xor_instruction
|   shl_instruction
|   shr_instruction
|   ld_instrucion
|   st_instruction
|   csrrd_instruction
|   csrwr_instruction
;

halt_instruction:
    HALT {/*DONE*/}
;

int_instruction:
    INT {/*DONE*/}
;

iret_instruction:
    IRET {/*DONE*/}
;

call_instruction:
    CALL branch_operand {
        auto& var = Collector::get_instance().get_branch_operand();
        if ( std::holds_alternative<std::string>(var) ) {
            std::cout << "CALL SIMBOLCINA" << std::endl;
        }

        if ( std::holds_alternative<int32_t>(var) ) {
            std::cout << "CALL LITERALCINA" << std::endl;
        }
    }
;

ret_instruction:
    RET {/*DONE*/}
;

jmp_instruction:
    JMP branch_operand {/*DONE*/}
;

beq_instruction:
    BEQ gpr COMMA gpr COMMA branch_operand {/* SHOULD BE DONE */}
;

bne_instruction:
    BNE gpr COMMA gpr COMMA branch_operand {/* SHOULD BE DONE */}
;

bgt_instruction:
    BGT gpr COMMA gpr branch_operand {/* SHOULD BE DONE */}
;

push_instruction:
    PUSH gpr {/*DONE*/}
;

pop_instruction:
    POP gpr {/*DONE*/}
;

xchg_instrucion:
    XCHG gpr COMMA gpr {/*DONE*/}
;

add_instruction:
    ADD gpr COMMA gpr {/*DONE*/}
;

sub_instrucion:
    SUB gpr COMMA gpr {/*DONE*/}
;

mul_instruction:
    MUL gpr COMMA gpr {/*DONE*/}
;

div_instruction:
    DIV gpr COMMA gpr {/*DONE*/}
;

not_instruction:
    NOT gpr {/*DONE*/}
;

and_instruction:
    AND gpr COMMA gpr {/*DONE*/}
;

or_instruction:
    OR gpr COMMA gpr {/*DONE*/}
;

xor_instruction:
    XOR gpr COMMA gpr {/*DONE*/}
;

shl_instruction:
    SHL gpr COMMA gpr {/*DONE*/}
;

shr_instruction:
   SHR gpr COMMA gpr {/*DONE*/}
;

ld_instrucion:
    LD operand COMMA gpr {/*HELL*/}
;

st_instruction:
    ST gpr COMMA operand {/*HELL*/}
;

csrrd_instruction:
    CSRRD csr COMMA gpr {/* NOT DONE YET */}
;

csrwr_instruction:
    CSRWR gpr COMMA csr {/* NOT DONE YET */}
;

directive:
    global_directive
|   extern_directive
|   section_directive
|   word_directive
|   skip_directive
|   ascii_directive
|   equ_directive
|   end_directive
;

global_directive:
    GLOBAL symbols {
        auto& c = Collector::get_instance();
        auto arr = c.get_symbols_and_literals();
        
        std::vector<std::string> to_send;

        for(auto& e : arr) {
            if( std::holds_alternative<std::string>(e)) {
                to_send.push_back(std::get<std::string>(e));
            }
        }

        Asembler::file_actions.push_back(
            std::make_unique<directive_global_and_extern>(to_send)
        );

        c.clear_symbols_and_literals();
    }
;
extern_directive:
    EXTERN symbols {
        auto& c = Collector::get_instance();
        auto arr = c.get_symbols_and_literals();
        
        std::vector<std::string> to_send;

        for(auto& e : arr) {
            if( std::holds_alternative<std::string>(e)) {
                to_send.push_back(std::get<std::string>(e));
            }
        }

        Asembler::file_actions.push_back(
            std::make_unique<directive_global_and_extern>(to_send)
        );

        c.clear_symbols_and_literals();

    }
;
section_directive:
    SECTION IDENTIFIER {
        auto& c = Collector::get_instance();

        Asembler::file_actions.push_back(
            std::make_unique<directive_section>(std::string($2))
        );
    }
;
word_directive:
    WORD symbols {/* DONE */}
|   WORD literal_list {/* DONE */}
;
skip_directive:
    SKIP literal {
        auto& c = Collector::get_instance();

        Asembler::file_actions.push_back(
            std::make_unique<directive_skip>($2)
        );
    }
;
ascii_directive:
    ASCII STRING {/* NOT DONE */}
;
equ_directive:
    EQU IDENTIFIER COMMA {/* OVO SE PRAVIMO DA NE POSTOJI DUZE VREME*/}
;
end_directive:
    END {;}
;



%%
